// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.5
// source: dagvm/dagvm.proto

package dagvm

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// DAGVMClient is the client API for DAGVM service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DAGVMClient interface {
	// Common VM
	Initialize(ctx context.Context, in *InitializeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SetState(ctx context.Context, in *SetStateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Shutdown(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CreateHandlers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CreateHandlersResponse, error)
	CreateStaticHandlers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CreateStaticHandlersResponse, error)
	Connected(ctx context.Context, in *ConnectedRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Disconnected(ctx context.Context, in *DisconnectedRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Health(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*HealthResponse, error)
	Version(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*VersionResponse, error)
	AppRequest(ctx context.Context, in *AppRequestMsg, opts ...grpc.CallOption) (*emptypb.Empty, error)
	AppRequestFailed(ctx context.Context, in *AppRequestFailedMsg, opts ...grpc.CallOption) (*emptypb.Empty, error)
	AppResponse(ctx context.Context, in *AppResponseMsg, opts ...grpc.CallOption) (*emptypb.Empty, error)
	AppGossip(ctx context.Context, in *AppGossipMsg, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DAG VM
	GetTx(ctx context.Context, in *GetTxRequest, opts ...grpc.CallOption) (*GetTxResponse, error)
	PendingTxs(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PendingTxsResponse, error)
	ParseTx(ctx context.Context, in *ParseTxRequest, opts ...grpc.CallOption) (*ParseTxResponse, error)
	// Tx
	TxAccept(ctx context.Context, in *TxAcceptRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	TxReject(ctx context.Context, in *TxRejectRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	TxVerify(ctx context.Context, in *TxVerifyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	TxDependencies(ctx context.Context, in *TxDependenciesRequest, opts ...grpc.CallOption) (*TxDependenciesResponse, error)
	TxWhitelist(ctx context.Context, in *TxWhitelistRequest, opts ...grpc.CallOption) (*TxWhitelistResponse, error)
	TxHasWhitelist(ctx context.Context, in *TxHasWhitelistRequest, opts ...grpc.CallOption) (*TxHasWhitelistResponse, error)
	TxInputIDs(ctx context.Context, in *TxInputIDsRequest, opts ...grpc.CallOption) (*TxInputIDsResponse, error)
}

type dAGVMClient struct {
	cc grpc.ClientConnInterface
}

func NewDAGVMClient(cc grpc.ClientConnInterface) DAGVMClient {
	return &dAGVMClient{cc}
}

func (c *dAGVMClient) Initialize(ctx context.Context, in *InitializeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/dagvm.DAGVM/Initialize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dAGVMClient) SetState(ctx context.Context, in *SetStateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/dagvm.DAGVM/SetState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dAGVMClient) Shutdown(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/dagvm.DAGVM/Shutdown", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dAGVMClient) CreateHandlers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CreateHandlersResponse, error) {
	out := new(CreateHandlersResponse)
	err := c.cc.Invoke(ctx, "/dagvm.DAGVM/CreateHandlers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dAGVMClient) CreateStaticHandlers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CreateStaticHandlersResponse, error) {
	out := new(CreateStaticHandlersResponse)
	err := c.cc.Invoke(ctx, "/dagvm.DAGVM/CreateStaticHandlers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dAGVMClient) Connected(ctx context.Context, in *ConnectedRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/dagvm.DAGVM/Connected", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dAGVMClient) Disconnected(ctx context.Context, in *DisconnectedRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/dagvm.DAGVM/Disconnected", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dAGVMClient) Health(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*HealthResponse, error) {
	out := new(HealthResponse)
	err := c.cc.Invoke(ctx, "/dagvm.DAGVM/Health", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dAGVMClient) Version(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*VersionResponse, error) {
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, "/dagvm.DAGVM/Version", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dAGVMClient) AppRequest(ctx context.Context, in *AppRequestMsg, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/dagvm.DAGVM/AppRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dAGVMClient) AppRequestFailed(ctx context.Context, in *AppRequestFailedMsg, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/dagvm.DAGVM/AppRequestFailed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dAGVMClient) AppResponse(ctx context.Context, in *AppResponseMsg, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/dagvm.DAGVM/AppResponse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dAGVMClient) AppGossip(ctx context.Context, in *AppGossipMsg, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/dagvm.DAGVM/AppGossip", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dAGVMClient) GetTx(ctx context.Context, in *GetTxRequest, opts ...grpc.CallOption) (*GetTxResponse, error) {
	out := new(GetTxResponse)
	err := c.cc.Invoke(ctx, "/dagvm.DAGVM/GetTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dAGVMClient) PendingTxs(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PendingTxsResponse, error) {
	out := new(PendingTxsResponse)
	err := c.cc.Invoke(ctx, "/dagvm.DAGVM/PendingTxs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dAGVMClient) ParseTx(ctx context.Context, in *ParseTxRequest, opts ...grpc.CallOption) (*ParseTxResponse, error) {
	out := new(ParseTxResponse)
	err := c.cc.Invoke(ctx, "/dagvm.DAGVM/ParseTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dAGVMClient) TxAccept(ctx context.Context, in *TxAcceptRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/dagvm.DAGVM/TxAccept", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dAGVMClient) TxReject(ctx context.Context, in *TxRejectRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/dagvm.DAGVM/TxReject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dAGVMClient) TxVerify(ctx context.Context, in *TxVerifyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/dagvm.DAGVM/TxVerify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dAGVMClient) TxDependencies(ctx context.Context, in *TxDependenciesRequest, opts ...grpc.CallOption) (*TxDependenciesResponse, error) {
	out := new(TxDependenciesResponse)
	err := c.cc.Invoke(ctx, "/dagvm.DAGVM/TxDependencies", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dAGVMClient) TxWhitelist(ctx context.Context, in *TxWhitelistRequest, opts ...grpc.CallOption) (*TxWhitelistResponse, error) {
	out := new(TxWhitelistResponse)
	err := c.cc.Invoke(ctx, "/dagvm.DAGVM/TxWhitelist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dAGVMClient) TxHasWhitelist(ctx context.Context, in *TxHasWhitelistRequest, opts ...grpc.CallOption) (*TxHasWhitelistResponse, error) {
	out := new(TxHasWhitelistResponse)
	err := c.cc.Invoke(ctx, "/dagvm.DAGVM/TxHasWhitelist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dAGVMClient) TxInputIDs(ctx context.Context, in *TxInputIDsRequest, opts ...grpc.CallOption) (*TxInputIDsResponse, error) {
	out := new(TxInputIDsResponse)
	err := c.cc.Invoke(ctx, "/dagvm.DAGVM/TxInputIDs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DAGVMServer is the server API for DAGVM service.
// All implementations must embed UnimplementedDAGVMServer
// for forward compatibility
type DAGVMServer interface {
	// Common VM
	Initialize(context.Context, *InitializeRequest) (*emptypb.Empty, error)
	SetState(context.Context, *SetStateRequest) (*emptypb.Empty, error)
	Shutdown(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	CreateHandlers(context.Context, *emptypb.Empty) (*CreateHandlersResponse, error)
	CreateStaticHandlers(context.Context, *emptypb.Empty) (*CreateStaticHandlersResponse, error)
	Connected(context.Context, *ConnectedRequest) (*emptypb.Empty, error)
	Disconnected(context.Context, *DisconnectedRequest) (*emptypb.Empty, error)
	Health(context.Context, *emptypb.Empty) (*HealthResponse, error)
	Version(context.Context, *emptypb.Empty) (*VersionResponse, error)
	AppRequest(context.Context, *AppRequestMsg) (*emptypb.Empty, error)
	AppRequestFailed(context.Context, *AppRequestFailedMsg) (*emptypb.Empty, error)
	AppResponse(context.Context, *AppResponseMsg) (*emptypb.Empty, error)
	AppGossip(context.Context, *AppGossipMsg) (*emptypb.Empty, error)
	// DAG VM
	GetTx(context.Context, *GetTxRequest) (*GetTxResponse, error)
	PendingTxs(context.Context, *emptypb.Empty) (*PendingTxsResponse, error)
	ParseTx(context.Context, *ParseTxRequest) (*ParseTxResponse, error)
	// Tx
	TxAccept(context.Context, *TxAcceptRequest) (*emptypb.Empty, error)
	TxReject(context.Context, *TxRejectRequest) (*emptypb.Empty, error)
	TxVerify(context.Context, *TxVerifyRequest) (*emptypb.Empty, error)
	TxDependencies(context.Context, *TxDependenciesRequest) (*TxDependenciesResponse, error)
	TxWhitelist(context.Context, *TxWhitelistRequest) (*TxWhitelistResponse, error)
	TxHasWhitelist(context.Context, *TxHasWhitelistRequest) (*TxHasWhitelistResponse, error)
	TxInputIDs(context.Context, *TxInputIDsRequest) (*TxInputIDsResponse, error)
	mustEmbedUnimplementedDAGVMServer()
}

// UnimplementedDAGVMServer must be embedded to have forward compatible implementations.
type UnimplementedDAGVMServer struct {
}

func (UnimplementedDAGVMServer) Initialize(context.Context, *InitializeRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Initialize not implemented")
}
func (UnimplementedDAGVMServer) SetState(context.Context, *SetStateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetState not implemented")
}
func (UnimplementedDAGVMServer) Shutdown(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Shutdown not implemented")
}
func (UnimplementedDAGVMServer) CreateHandlers(context.Context, *emptypb.Empty) (*CreateHandlersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateHandlers not implemented")
}
func (UnimplementedDAGVMServer) CreateStaticHandlers(context.Context, *emptypb.Empty) (*CreateStaticHandlersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateStaticHandlers not implemented")
}
func (UnimplementedDAGVMServer) Connected(context.Context, *ConnectedRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Connected not implemented")
}
func (UnimplementedDAGVMServer) Disconnected(context.Context, *DisconnectedRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Disconnected not implemented")
}
func (UnimplementedDAGVMServer) Health(context.Context, *emptypb.Empty) (*HealthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Health not implemented")
}
func (UnimplementedDAGVMServer) Version(context.Context, *emptypb.Empty) (*VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedDAGVMServer) AppRequest(context.Context, *AppRequestMsg) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppRequest not implemented")
}
func (UnimplementedDAGVMServer) AppRequestFailed(context.Context, *AppRequestFailedMsg) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppRequestFailed not implemented")
}
func (UnimplementedDAGVMServer) AppResponse(context.Context, *AppResponseMsg) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppResponse not implemented")
}
func (UnimplementedDAGVMServer) AppGossip(context.Context, *AppGossipMsg) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppGossip not implemented")
}
func (UnimplementedDAGVMServer) GetTx(context.Context, *GetTxRequest) (*GetTxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTx not implemented")
}
func (UnimplementedDAGVMServer) PendingTxs(context.Context, *emptypb.Empty) (*PendingTxsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PendingTxs not implemented")
}
func (UnimplementedDAGVMServer) ParseTx(context.Context, *ParseTxRequest) (*ParseTxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ParseTx not implemented")
}
func (UnimplementedDAGVMServer) TxAccept(context.Context, *TxAcceptRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TxAccept not implemented")
}
func (UnimplementedDAGVMServer) TxReject(context.Context, *TxRejectRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TxReject not implemented")
}
func (UnimplementedDAGVMServer) TxVerify(context.Context, *TxVerifyRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TxVerify not implemented")
}
func (UnimplementedDAGVMServer) TxDependencies(context.Context, *TxDependenciesRequest) (*TxDependenciesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TxDependencies not implemented")
}
func (UnimplementedDAGVMServer) TxWhitelist(context.Context, *TxWhitelistRequest) (*TxWhitelistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TxWhitelist not implemented")
}
func (UnimplementedDAGVMServer) TxHasWhitelist(context.Context, *TxHasWhitelistRequest) (*TxHasWhitelistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TxHasWhitelist not implemented")
}
func (UnimplementedDAGVMServer) TxInputIDs(context.Context, *TxInputIDsRequest) (*TxInputIDsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TxInputIDs not implemented")
}
func (UnimplementedDAGVMServer) mustEmbedUnimplementedDAGVMServer() {}

// UnsafeDAGVMServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DAGVMServer will
// result in compilation errors.
type UnsafeDAGVMServer interface {
	mustEmbedUnimplementedDAGVMServer()
}

func RegisterDAGVMServer(s grpc.ServiceRegistrar, srv DAGVMServer) {
	s.RegisterService(&DAGVM_ServiceDesc, srv)
}

func _DAGVM_Initialize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitializeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DAGVMServer).Initialize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagvm.DAGVM/Initialize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DAGVMServer).Initialize(ctx, req.(*InitializeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DAGVM_SetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DAGVMServer).SetState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagvm.DAGVM/SetState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DAGVMServer).SetState(ctx, req.(*SetStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DAGVM_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DAGVMServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagvm.DAGVM/Shutdown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DAGVMServer).Shutdown(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DAGVM_CreateHandlers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DAGVMServer).CreateHandlers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagvm.DAGVM/CreateHandlers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DAGVMServer).CreateHandlers(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DAGVM_CreateStaticHandlers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DAGVMServer).CreateStaticHandlers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagvm.DAGVM/CreateStaticHandlers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DAGVMServer).CreateStaticHandlers(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DAGVM_Connected_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DAGVMServer).Connected(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagvm.DAGVM/Connected",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DAGVMServer).Connected(ctx, req.(*ConnectedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DAGVM_Disconnected_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DAGVMServer).Disconnected(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagvm.DAGVM/Disconnected",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DAGVMServer).Disconnected(ctx, req.(*DisconnectedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DAGVM_Health_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DAGVMServer).Health(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagvm.DAGVM/Health",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DAGVMServer).Health(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DAGVM_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DAGVMServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagvm.DAGVM/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DAGVMServer).Version(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DAGVM_AppRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DAGVMServer).AppRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagvm.DAGVM/AppRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DAGVMServer).AppRequest(ctx, req.(*AppRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _DAGVM_AppRequestFailed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppRequestFailedMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DAGVMServer).AppRequestFailed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagvm.DAGVM/AppRequestFailed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DAGVMServer).AppRequestFailed(ctx, req.(*AppRequestFailedMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _DAGVM_AppResponse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppResponseMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DAGVMServer).AppResponse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagvm.DAGVM/AppResponse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DAGVMServer).AppResponse(ctx, req.(*AppResponseMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _DAGVM_AppGossip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppGossipMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DAGVMServer).AppGossip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagvm.DAGVM/AppGossip",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DAGVMServer).AppGossip(ctx, req.(*AppGossipMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _DAGVM_GetTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DAGVMServer).GetTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagvm.DAGVM/GetTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DAGVMServer).GetTx(ctx, req.(*GetTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DAGVM_PendingTxs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DAGVMServer).PendingTxs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagvm.DAGVM/PendingTxs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DAGVMServer).PendingTxs(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DAGVM_ParseTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParseTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DAGVMServer).ParseTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagvm.DAGVM/ParseTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DAGVMServer).ParseTx(ctx, req.(*ParseTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DAGVM_TxAccept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxAcceptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DAGVMServer).TxAccept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagvm.DAGVM/TxAccept",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DAGVMServer).TxAccept(ctx, req.(*TxAcceptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DAGVM_TxReject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxRejectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DAGVMServer).TxReject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagvm.DAGVM/TxReject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DAGVMServer).TxReject(ctx, req.(*TxRejectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DAGVM_TxVerify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxVerifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DAGVMServer).TxVerify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagvm.DAGVM/TxVerify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DAGVMServer).TxVerify(ctx, req.(*TxVerifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DAGVM_TxDependencies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxDependenciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DAGVMServer).TxDependencies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagvm.DAGVM/TxDependencies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DAGVMServer).TxDependencies(ctx, req.(*TxDependenciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DAGVM_TxWhitelist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxWhitelistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DAGVMServer).TxWhitelist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagvm.DAGVM/TxWhitelist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DAGVMServer).TxWhitelist(ctx, req.(*TxWhitelistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DAGVM_TxHasWhitelist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxHasWhitelistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DAGVMServer).TxHasWhitelist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagvm.DAGVM/TxHasWhitelist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DAGVMServer).TxHasWhitelist(ctx, req.(*TxHasWhitelistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DAGVM_TxInputIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxInputIDsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DAGVMServer).TxInputIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dagvm.DAGVM/TxInputIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DAGVMServer).TxInputIDs(ctx, req.(*TxInputIDsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DAGVM_ServiceDesc is the grpc.ServiceDesc for DAGVM service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DAGVM_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "dagvm.DAGVM",
	HandlerType: (*DAGVMServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Initialize",
			Handler:    _DAGVM_Initialize_Handler,
		},
		{
			MethodName: "SetState",
			Handler:    _DAGVM_SetState_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _DAGVM_Shutdown_Handler,
		},
		{
			MethodName: "CreateHandlers",
			Handler:    _DAGVM_CreateHandlers_Handler,
		},
		{
			MethodName: "CreateStaticHandlers",
			Handler:    _DAGVM_CreateStaticHandlers_Handler,
		},
		{
			MethodName: "Connected",
			Handler:    _DAGVM_Connected_Handler,
		},
		{
			MethodName: "Disconnected",
			Handler:    _DAGVM_Disconnected_Handler,
		},
		{
			MethodName: "Health",
			Handler:    _DAGVM_Health_Handler,
		},
		{
			MethodName: "Version",
			Handler:    _DAGVM_Version_Handler,
		},
		{
			MethodName: "AppRequest",
			Handler:    _DAGVM_AppRequest_Handler,
		},
		{
			MethodName: "AppRequestFailed",
			Handler:    _DAGVM_AppRequestFailed_Handler,
		},
		{
			MethodName: "AppResponse",
			Handler:    _DAGVM_AppResponse_Handler,
		},
		{
			MethodName: "AppGossip",
			Handler:    _DAGVM_AppGossip_Handler,
		},
		{
			MethodName: "GetTx",
			Handler:    _DAGVM_GetTx_Handler,
		},
		{
			MethodName: "PendingTxs",
			Handler:    _DAGVM_PendingTxs_Handler,
		},
		{
			MethodName: "ParseTx",
			Handler:    _DAGVM_ParseTx_Handler,
		},
		{
			MethodName: "TxAccept",
			Handler:    _DAGVM_TxAccept_Handler,
		},
		{
			MethodName: "TxReject",
			Handler:    _DAGVM_TxReject_Handler,
		},
		{
			MethodName: "TxVerify",
			Handler:    _DAGVM_TxVerify_Handler,
		},
		{
			MethodName: "TxDependencies",
			Handler:    _DAGVM_TxDependencies_Handler,
		},
		{
			MethodName: "TxWhitelist",
			Handler:    _DAGVM_TxWhitelist_Handler,
		},
		{
			MethodName: "TxHasWhitelist",
			Handler:    _DAGVM_TxHasWhitelist_Handler,
		},
		{
			MethodName: "TxInputIDs",
			Handler:    _DAGVM_TxInputIDs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dagvm/dagvm.proto",
}
